#version 450
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_ARB_shading_language_include : require

#include "common/define.glsl"
#include "common/bitwise.glsl"
#include "common/raycast.glsl"
#include "common/node_buffer.glsl"

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

const vec3 face_offsets[6] = {
    vec3(-1, 0, 0),
    vec3(1, 0, 0),
    vec3(0, -1, 0),
    vec3(0, 1, 0),
    vec3(0, 0, -1),
    vec3(0, 0, 1),
};

const vec3 sun_dir = normalize(vec3(0, 1, 0));

bool get_position(uint node_id, inout vec3 origin, inout float size) {
    uint node_path = nodes[node_id].path;

    // get the node's position and size
    uint test_current = 0;

    for(uint i = 0; i < 10; i ++) {
        Node current = nodes[test_current];

        // if we reach a leaf, we know we reached our target node
        bool is_leaf = (current.data & 0x80000000) != 0;
        if (is_leaf) {
            break;
        }

        // pull the three lsb from the node path
        uint child_index = node_path & 0x7;
        node_path >>= 3;

        // decent into the child
        test_current = current.data + child_index;
        size /= 2;
        origin += offset_lookup[child_index] * size;
    }

    return test_current == node_id;
}

vec3 color_voxel(uint node_id) {
    Node node = nodes[node_id];
    vec3 node_color = u32_to_u8x4(node.data).gba / 255.0;
    vec3 origin = octree_origin;
    float size = octree_size;

    // calculate the node's position and size
    if (!get_position(node_id, origin, size)) {
        return vec3(0);
    }
    vec3 mid = origin + size / 2;

    // cast sun light
    int prev_intersect = 0;
    for (int i = 0; i < 6; i++) {
        vec3 ray_pos = mid;
        vec3 ray_dir = sun_dir;

        Ray ray = CreateRay(ray_pos, ray_dir);
        uint skips = 1;
        uint intersection = intersect_octree(ray, skips);
        if (intersection != 0) {
            prev_intersect ++;
        }
    }

    return vec3(1) - prev_intersect / 6.0;
}

// Voxel render manages per-voxel rendering. A thread is spawned for each voxel,
// discarded if the voxel is not visible, and rendered if it is.
void main() {
    // Get the voxel id
    uint node_id = gl_GlobalInvocationID.x;

    // discard if > MAX_NODES
    if (node_id >= MAX_NODES) {
        return;
    }

    // discard if flag in node_buffer is not set
    uvec4 node_data = u32_to_u8x4(node_buffer[node_id]);
    if (node_data.a == 0) {
        return;
    }

    uvec3 node_color = uvec3(color_voxel(node_id) * 255);

    // debug: set the color in node_buffer to red
    uvec4 out_node_data = uvec4(node_color, 255);
    node_buffer[node_id] = u8x4_to_u32(out_node_data);
}