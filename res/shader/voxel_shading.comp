#version 450
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_ARB_shading_language_include : require

#include "common/define.glsl"
#include "common/bitwise.glsl"
#include "common/raycast.glsl"
#include "common/node_buffer.glsl"
#include "common/rand.glsl"

layout (local_size_x = 1024) in;

const vec3 faces[6] = vec3[6](
    vec3(1, 0, 0),
    vec3(-1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, -1, 0),
    vec3(0, 0, 1),
    vec3(0, 0, -1)
);

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uvec2 node = node_buffer[idx];
    if (node == uvec2(0)) {
        return;
    }

    // Get the current node
    uint64_t path = uvec2_to_u64(node);
    vec3 voxel_origin;
    float voxel_scale;
    uint voxel_idx;
    decode_path(path, voxel_origin, voxel_scale, voxel_idx);

    // Get the base material
    uint encoded_rgb = Attributes[voxel_idx].rgb;
    vec3 base_rgb = vec3(u32_to_u8x4(encoded_rgb).yzw / 255.0);

    // Cast a shadow ray
    vec3 light_dir = normalize(vec3(0, 1, 1));

    vec3 voxel_center = voxel_origin + vec3(voxel_scale * 0.5);
    float misses = 0;
    uint sample_count = 60;
    for (int i = 0; i < sample_count; i++) {
        float idx = i * 3 + time;
        float x = random(vec4(voxel_center, idx + 0)) * 2 - 1;
        float y = random(vec4(voxel_center, idx + 1)) * 2 - 1;
        float z = random(vec4(voxel_center, idx + 2)) * 2 - 1;

        vec3 ray_pos = voxel_center + voxel_scale * normalize(vec3(x, y, z));
        // vec3 ray_pos = voxel_center + voxel_scale * 0.55 * faces[i];

        uint _parent;
        float _t;
        uint64_t _path;
        vec3 _debug;
        bool hit = raymarch(ray_pos, light_dir, 1, 0, _parent, _t, _path, _debug);

        if (!hit) {
            misses += 1;
        }
    }

    float miss_ratio = misses / sample_count;
    base_rgb *= miss_ratio;

    encoded_rgb = u8x4_to_u32(uvec4(base_rgb * 255.0, 1));
    node_buffer[idx] = uvec2(encoded_rgb, 0);

    // // Shadow ray
    // vec3 light_dir = normalize(vec3(1, 0, 0));
    // vec3 ray_pos = voxel_pos + voxel_scale;
    // vec3 ray_dir = light_dir;

    // uint _parent;
    // float _t;
    // uint64_t _path;
    // vec3 _debug;
    // bool hit = raymarch(ray_pos, ray_dir, 0, 1, _parent, _t, _path, _debug);

    // if (hit) {
    //     voxel_idx = _parent;
    // }

    // Attribute voxel = Attributes[voxel_idx];
    // uvec3 voxel_color = u32_to_u8x4(voxel.rgb).yzw;
    // outColor = vec4(voxel_color / 255.0, 255);
}